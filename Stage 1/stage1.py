# -*- coding: utf-8 -*-
"""Stage1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11ADF5RAFblg5Md-7mJFRIrUVib1zIfhb

## Stage 1
"""

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style="whitegrid", context="notebook", font_scale=1.05)
plt.rcParams['figure.dpi'] = 120

# -------------------------
# Helper: try load or simulate
# -------------------------
def load_or_simulate_counts(counts_path="normalized_counts.csv",
                            meta_path="sample_metadata.csv",
                            genes=2000, samples_per_group=4):
    """
    Expects counts CSV with genes as rows, samples as columns.
    Expects sample_metadata CSV with columns: sample, group (HBR/UHR)
    Returns: counts_df (genes x samples), metadata_df
    """
    if os.path.exists(counts_path) and os.path.exists(meta_path):
        counts = pd.read_csv(counts_path, index_col=0)
        meta = pd.read_csv(meta_path)
        return counts, meta
    else:
        # Simulate toy data if files not present
        rng = np.random.default_rng(0)
        n_samples = samples_per_group * 2
        sample_names = [f"HBR_{i+1}" for i in range(samples_per_group)] + [f"UHR_{i+1}" for i in range(samples_per_group)]
        gene_names = [f"GENE{g+1}" for g in range(genes)]
        # baseline expression + group shift for subset of genes
        data = rng.normal(loc=5.0, scale=1.0, size=(genes, n_samples))
        # introduce differential expression in first 50 genes
        data[:50, samples_per_group:] += 2.0  # up in UHR
        counts = pd.DataFrame(data, index=gene_names, columns=sample_names)
        meta = pd.DataFrame({"sample": sample_names, "group": ["HBR"]*samples_per_group + ["UHR"]*samples_per_group})
        print("Data files not found — using simulated counts and metadata for demo.")
        return counts, meta

def load_or_simulate_deg(deg_path="deg_results.csv", n_genes=1000):
    """
    Expects DEG CSV with at least columns: gene, log2FoldChange, padj, chromosome
    If not found, simulate results including chromosome column.
    """
    if os.path.exists(deg_path):
        deg = pd.read_csv(deg_path)
        # Ensure columns exist
        for c in ["gene","log2FoldChange","padj"]:
            if c not in deg.columns:
                raise ValueError(f"DEG file missing required column: {c}")
        if "chromosome" not in deg.columns:
            deg["chromosome"] = ""  # will have to rely on other ways
        return deg
    else:
        rng = np.random.default_rng(1)
        genes = [f"GENE{g+1}" for g in range(n_genes)]
        log2fc = rng.normal(0, 1.5, size=n_genes)
        # make some strongly differential genes
        log2fc[:40] += np.where(rng.random(40) > 0.5, 2.5, -2.5)
        padj = np.clip(10**(-rng.normal(2, 1.5, size=n_genes)), 1e-8, 1.0)
        # assign chromosomes randomly and force some on chr22
        chroms = rng.integers(1, 23, size=n_genes).astype(str)
        # mark some as '22'
        chroms[:60] = "22"
        deg = pd.DataFrame({"gene": genes, "log2FoldChange": log2fc, "padj": padj, "chromosome": chroms})
        print("DEG file not found — using simulated differential expression results for demo.")
        return deg

# -------------------------
# Part A: Gene Expression Analysis
# -------------------------
# Load or simulate counts & deg results
counts_df, meta_df = load_or_simulate_counts()
deg_df = load_or_simulate_deg()

# a) Heatmap: choose top DE genes between HBR and UHR
# Approach: use deg_df to rank genes (abs log2FC & padj). If deg_df gene names correspond to counts_df index, match; otherwise, pick top variable genes.
def select_top_genes_for_heatmap(counts, deg, meta, top_n=50):
    # If gene names in deg intersect counts, rank from deg; else use variance
    intersect = set(counts.index) & set(deg['gene'])
    if len(intersect) >= top_n:
        deg_filtered = deg[deg['gene'].isin(intersect)].copy()
        # rank by padj then abs log2FC
        deg_filtered['score'] = -np.log10(deg_filtered['padj'] + 1e-300) * np.abs(deg_filtered['log2FoldChange'])
        top_genes = deg_filtered.sort_values('score', ascending=False).head(top_n)['gene'].tolist()
    else:
        # fallback to high variance genes from counts
        top_genes = counts.var(axis=1).sort_values(ascending=False).head(top_n).index.tolist()
    return top_genes

top_genes = select_top_genes_for_heatmap(counts_df, deg_df, meta_df, top_n=50)

# Prepare matrix for heatmap: z-score by gene (row) for visualization
expr_sub = counts_df.loc[top_genes]
expr_z = expr_sub.sub(expr_sub.mean(axis=1), axis=0).div(expr_sub.std(axis=1).replace(0,1), axis=0)

# Create sample annotation colors for HBR/UHR
group_map = meta_df.set_index('sample')['group'].to_dict()
col_colors = pd.Series([group_map.get(s, "NA") for s in expr_z.columns], index=expr_z.columns)
lut = {"HBR":"#2b83ba", "UHR":"#fdae61", "NA":"#dddddd"}
col_colors_mapped = col_colors.map(lut)

# Plot clustered heatmap (genes & samples labelled)
g = sns.clustermap(expr_z, cmap="Blues", row_cluster=True, col_cluster=True,
                   figsize=(10, 12), col_colors=col_colors_mapped, xticklabels=True, yticklabels=True)
# add legend for sample groups
for label in lut:
    g.ax_col_dendrogram.bar(0, 0, color=lut[label], label=label, linewidth=0)
g.ax_col_dendrogram.legend(loc="center", ncol=3)
plt.suptitle("Clustered heatmap — top differentially expressed genes (z-scored)", y=1.02)
plt.show()

# b) Volcano plot for chromosome 22
# Filter DEGs on chromosome 22
chr22 = deg_df[deg_df['chromosome'].astype(str) == '22'].copy()
if chr22.empty:
    # fallback: take top 500 degs and mark a subset as chr22 for demo
    chr22 = deg_df.head(500).copy()

# compute -log10 padj (handle zeros)
chr22['padj'] = chr22['padj'].replace(0, 1e-300)
chr22['neglog10padj'] = -np.log10(chr22['padj'] + 1e-300)

# define significance
sig_thresh_padj = 0.05
fc_up = (chr22['log2FoldChange'] >= 1) & (chr22['padj'] <= sig_thresh_padj)
fc_down = (chr22['log2FoldChange'] <= -1) & (chr22['padj'] <= sig_thresh_padj)
chr22['sig_class'] = np.where(fc_up, 'Up', np.where(fc_down, 'Down', 'NotSig'))

# Plot volcano
plt.figure(figsize=(8,6))
palette = {'Up':'green', 'Down':'orange', 'NotSig':'grey'}
sns.scatterplot(data=chr22, x='log2FoldChange', y='neglog10padj', hue='sig_class',
                palette=palette, edgecolor=None, alpha=0.8)
plt.axvline(1, color='black', linestyle='--', linewidth=1)
plt.axvline(-1, color='black', linestyle='--', linewidth=1)
plt.xlabel('log2FoldChange')
plt.ylabel('-log10(padj)')
plt.title('Volcano plot — Chromosome 22 DEGs')
plt.legend(title='Significance', loc='upper right')
plt.tight_layout()
plt.show()

# -------------------------
# Part B: Breast Cancer Data Exploration
# -------------------------
from sklearn.datasets import load_breast_cancer

bc = load_breast_cancer()
bc_df = pd.DataFrame(bc.data, columns=bc.feature_names)
# scikit-learn's target: 0=malignant, 1=benign (historical); verify and map to M/B
# Actually for this dataset: target_names = ['malignant' 'benign'] and target 0=malignant
target_map = {0: 'M', 1: 'B'}
bc_df['diagnosis'] = [target_map[t] for t in bc.target]

# The user wants features with names like radius_mean, texture_mean, etc.
# Map the sklearn names to the user's naming scheme:
rename_map = {}
for col in bc_df.columns:
    # convert 'mean radius' -> 'radius_mean'
    new = col.replace('mean ', '').replace(' ', '_') + "_mean" if 'mean' in col else col.replace(' ', '_')
    # attempt to produce names like radius_mean, texture_mean, etc.
    # We'll do a smart mapping for the specified six features:
    # radius_mean, texture_mean, perimeter_mean, area_mean, smoothness_mean, compactness_mean
    pass

# manual mapping from sklearn's feature names to expected names
sk_to_user = {
    'mean radius': 'radius_mean',
    'mean texture': 'texture_mean',
    'mean perimeter': 'perimeter_mean',
    'mean area': 'area_mean',
    'mean smoothness': 'smoothness_mean',
    'mean compactness': 'compactness_mean'
}

# build a dataframe with the six features
rename_cols = {}
for skname, username in sk_to_user.items():
    # sklearn feature names given in bc.feature_names are like 'mean radius'
    # find matching column
    if skname in bc.feature_names:
        rename_cols[skname] = username = username

# Because bc.feature_names are exact strings, create mapping:
bc_small = pd.DataFrame({
    'radius_mean': bc_df['mean radius'],
    'texture_mean': bc_df['mean texture'],
    'perimeter_mean': bc_df['mean perimeter'],
    'area_mean': bc_df['mean area'],
    'smoothness_mean': bc_df['mean smoothness'],
    'compactness_mean': bc_df['mean compactness'],
    'diagnosis': bc_df['diagnosis']
})

# c) Scatter Plot (texture_mean vs radius_mean)
plt.figure(figsize=(7,5))
sns.scatterplot(data=bc_small, x='radius_mean', y='texture_mean', hue='diagnosis', alpha=0.8)
plt.xlabel("radius_mean")
plt.ylabel("texture_mean")
plt.title("Texture_mean vs Radius_mean colored by diagnosis (M = malignant, B = benign)")
plt.legend(title='Diagnosis')
plt.tight_layout()
plt.show()

# d) Correlation heatmap of the six key features with annotations
corr_features = ['radius_mean', 'texture_mean', 'perimeter_mean', 'area_mean', 'smoothness_mean', 'compactness_mean']
corr_mat = bc_small[corr_features].corr()

plt.figure(figsize=(8,6))
sns.heatmap(corr_mat, annot=True, fmt=".2f", cmap='coolwarm', vmin=-1, vmax=1, square=True,
            cbar_kws={'shrink':.7})
plt.title("Correlation matrix — selected breast cancer features")
plt.tight_layout()
plt.show()

# e) Scatter Plot (smoothness vs compactness) colored by diagnosis, with gridlines and labels
plt.figure(figsize=(7,5))
sns.scatterplot(data=bc_small, x='smoothness_mean', y='compactness_mean', hue='diagnosis', alpha=0.8)
plt.xlabel("smoothness_mean")
plt.ylabel("compactness_mean")
plt.title("Compactness_mean vs Smoothness_mean by diagnosis")
plt.grid(True, linestyle='--', alpha=0.4)
plt.legend(title='Diagnosis')
plt.tight_layout()
plt.show()

# f) Density Plot (KDE) of area_mean for M and B diagnoses on same axis
plt.figure(figsize=(7,5))
for label, grp in bc_small.groupby('diagnosis'):
    sns.kdeplot(grp['area_mean'], label=label, fill=False, common_norm=False)
plt.xlabel("area_mean")
plt.ylabel("Density (KDE)")
plt.title("Area_mean distribution by diagnosis (KDE)")
plt.legend(title='Diagnosis')
plt.tight_layout()
plt.show()

# -------------------------
# Notes / Next steps
# -------------------------
print("\nDone. Notes:")
print("- If you have your real files, place them in the Colab working directory with names:")
print("  * normalized_counts.csv  (genes x samples, index gene names)")
print("  * sample_metadata.csv    (columns: sample, group with values HBR or UHR)")
print("  * deg_results.csv        (columns: gene, log2FoldChange, padj, chromosome)")
print("- The code falls back to simulated demo data if files aren't found. Replace simulated parts with your real data for production analysis.")
print("- You can save figures with plt.savefig(...) before plt.show() if you want downloadable image files.")